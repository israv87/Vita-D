# -*- coding: utf-8 -*-
"""SVM-VITA-D.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MdegD1RlRktQ0kD-KMPLRZj2Q02cG7yx
"""

# Tratamiento de datos
# ==============================================================================
import pandas as pd
import numpy as np

# Gráficos
# ==============================================================================
import matplotlib.pyplot as plt
from matplotlib import style
import seaborn as sns
from mlxtend.plotting import plot_decision_regions

# Preprocesado y modelado
# ==============================================================================
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import accuracy_score

# Configuración matplotlib
# ==============================================================================
plt.rcParams['image.cmap'] = "bwr"
#plt.rcParams['figure.dpi'] = "100"
plt.rcParams['savefig.bbox'] = "tight"
style.use('ggplot') or plt.style.use('ggplot')

# Configuración warnings
# ==============================================================================
import warnings
warnings.filterwarnings('ignore')

import pandas as pd
import numpy as np
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
import matplotlib.pyplot as plt
# Asegúrate de tener instalado mlxtend para la visualización de la región de decisión
from mlxtend.plotting import plot_decision_regions

"""## Cargamos los datos de entrada del archivo csv"""

dataframe = pd.read_csv(r"/content/BDSeleccionadaV3.csv")
dataframe.head()

dataframe.describe()

import matplotlib.pyplot as plt
import seaborn as sns

# Tu código existente para actualizar la categoría de Vitamina D
def categorizar_vitamina_d_binario(valor):
    if valor < 17:
        return 0
    else:  # Valores iguales o superiores a 18 se marcan como 1, incluyendo los superiores a 35
        return 1

dataframe['CategoriaVitaD'] = dataframe['VitaminaD'].apply(categorizar_vitamina_d_binario)
dataframe['CategoriaVitaD'] = dataframe['CategoriaVitaD'].astype(int)
#print(dataframe.head())

print(dataframe.groupby('CategoriaVitaD').size())

# Crear un gráfico de dispersión
fig, ax = plt.subplots(figsize=(6,4))
ax.scatter(dataframe['Edad'], dataframe['MasaMusc'], c=dataframe['CategoriaVitaD'])
ax.set_title("Relación entre Edad y Masa Muscular por Categoría de Vitamina D")
ax.set_xlabel("Edad")
ax.set_ylabel("Masa Muscular")
plt.show()

X_train, X_test, y_train, y_test = train_test_split(
    dataframe.drop(columns=['CategoriaVitaD', 'VitaminaD','ExposicionMinutos','ExposicionDias'	]),  # Excluir 'VitaminaD' y 'CategoriaVitaD'
    dataframe['CategoriaVitaD'],
    random_state=123
)
y = dataframe['CategoriaVitaD']

# Dividir los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=16)
X.shape

# Usando kernel RBF para permitir la no linealidad
svm_model = SVC(kernel='rbf', C=1, gamma='auto')
svm_model.fit(X_train, y_train)

# prompt: Cómo puedo mejorar este código para ver las predicciones: # Paso 3: Realizar predicciones
# y_pred = svm_model.predict(X_test)

# Paso 3: Realizar predicciones
y_pred = svm_model.predict(X_test)

# Paso 4: Evaluar el modelo
accuracy = accuracy_score(y_test, y_pred)
print("Precisión del modelo:", accuracy)

# Paso 5: Imprimir las predicciones
print("Predicciones:", y_pred)

# Evaluar el modelo
conf_mat = confusion_matrix(y_test, y_pred)
accuracy = accuracy_score(y_test, y_pred) * 100
report = classification_report(y_test, y_pred)

# Imprimir los resultados
print("Matriz de confusión")
print("-------------------")
print(conf_mat)
print()
print(f"El accuracy de test es: {accuracy} %")
print()
print(report)